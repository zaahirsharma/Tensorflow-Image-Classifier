# Tensorflow allows bringing in pre-trained machine learning model that can look at image and classify
# OpenCV allows manipulation on loaded image to pass into TensorFlow

# Importing OpenCV essentially
import cv2
# Installed by deafult with Tensorflow
import numpy as np
import streamlit as st

# Keras contains pre-trained machine learning models
# The model used is MobileNetV2 (lightweight, run on laptop)
from tensorflow.keras.applications.mobilenet_v2 import (
    MobileNetV2,
    preprocess_input,
    decode_predictions
)

# Importing an image library with python, comes from cv2 by default
from PIL import Image


# Load in the machine learning model
def load_model():
    # Convolutional Neural Network
    # Employs certain architecture (weights) to look at images
    # The weights are the learned values that makes the model function accordingly
    model = MobileNetV2(weights="imagenet")
    return model


# Take in image, use OpenCV and numpy, convert image into something understanable by model
def preprocess_image(image):
    # Makes image into an array of numbers using numpy
    img = np.array(image)
    # Resizing image into 224x224 pixels, might lose image details but it is the size model accepts
    img = cv2.resize(img, (224, 224))
    # Fuction from model, pre-process to sent to model
    img = preprocess_input(img)
    # Taking single image, convert to format that represents multiple images b/c model can accept batch of images
    # Makes it look like multiple images, wrapping image in a list for model input
    img = np.expand_dims(img, axis=0)
    return img

def classify_image(model, image):
    try:
        processed_image = preprocess_image(image)
        # Passing image to the model
        predictions = model.predict(processed_image)
        # Take numeric predictions generated by model, covert into string labels to see predictions, taking top 3 prediction, using the first one ([0])
        # Model expecting multiple images, grabbing only response, and get decoded version
        decoded_predictions = decode_predictions(predictions, top=3)[0]
        
        return decoded_predictions
    except Exception as e:
        st.error(f"Error classifying image: {str(e)}")
        return None
    
# Making streamlit UI
def main():
    st.set_page_config(page_title="AI Image Classifier", page_icon="ðŸ“¸", layout="centered")
    st.title("AI Image Classifier")
    st.write("Upload an image and let AI tell you what is in it!")
    
    # Can cache resources used frequently
    # When called, if model already loaded, it will just return the loaded model, not run the function again
    # This is useful as streamlit re-runs the entire program everytime a state changes
    @st.cache_resource
    def load_cached_model():
        return load_model()
    
    model = load_cached_model()
    
    uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "png"])
    
    # Check if file is uploaded
    if uploaded_file is not None:
        # Displaying image on screen, with caption, use whole width of screen
        image = st.image(
            uploaded_file, caption="Uploaded Image",
            use_container_width=True
        )
        # Create button to start model run
        btn = st.button("Classify Image")
        # If button was pressed
        if btn:
            # Create loading icon, run this while loading
            with st.spinner("Analyzing Image..."):
                # Opening image
                image = Image.open(uploaded_file)
                predictions = classify_image(model, image)
                
                # Check if predictions are existing
                if predictions:
                    st.subheader("Predictions")
                    # Predictions contain (Index, Label, Score), only want last 2
                    for _, label, score in predictions:
                        # Loop through existing predictions
                        # Display the prediction and percentage accuracy
                        st.write(f"**{label}**: {score:.2%}")

if __name__ == "__main__":
    main()